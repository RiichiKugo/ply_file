<!DOCTYPE html>
<html lang="ja">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1"/>
 <title>three.js</title>
 <meta name="robots" content="noindex,follow">
</head>
<body>
 <canvas id="canvas"></canvas>
 <script src="three/three.min.js"></script>
<script src="three/OrbitControls.js"></script>
<script src="three/OBJLoader.js"></script>
<script src="three/MTLLoader.js"></script>
<script src="three/PLYLoader.js"></script>
<script src="three/PLYExporter.js"></script>
<script src="three/TrackballControls.js"></script>
<div>
<label><input type="range" id="sliderWidth" step="0.1" min="0" max="3" value="1">X</label>
<label><input type="range" id="sliderHeight" step="0.1" min="0" max="3" value="1">Y</label>
<label><input type="range" id="sliderDepth" step="0.1" min="0" max="3" value="1">Z</label>
</div>
<div>
<input type="button" value="CropMode:ON" id="Cropmode">
<input type="button" value="Cropping!!" id="cropbutton">
</div>
 <script>
     //基本設定
 var width = 450;
 var height = 200;

document.getElementById("cropbutton").style.visibility ="hidden";

 var renderer = new THREE.WebGLRenderer({
  canvas: document.querySelector("#canvas"),
  alpha: true
 });
 renderer.setPixelRatio(window.devicePixelRatio);
 renderer.setSize(width, height);
  renderer.localClippingEnabled = true;
  document.body.appendChild( renderer.domElement );
 var scene = new THREE.Scene();
  //scene.add(new THREE.AxesHelper(5));
  var objects = [];

 // カメラ設定
 var camera = new THREE.PerspectiveCamera(30,width / height,1,1000000);
 //camera.position.set(1,100, 50); 
  camera.position.set(-2,-1,-7); 
  //camera.position.set(1,100,1000); 

  // TrackballControlsインスタンス作成
  var controls = new THREE.TrackballControls( camera ,renderer.domElement);

 // ライト設定
 ambientLight = new THREE.AmbientLight(0xffffff);
 hemisphereLight = new THREE.HemisphereLight(0xffffff,0x4169e1, 0.15);
 scene.add(hemisphereLight);
 scene.add(ambientLight);

 // ★追加 マウス操作
 //var Orbitcontrols = new THREE.OrbitControls(camera,renderer.domElement);
 //Orbitcontrols.enableZoom = true;

 var obj = new THREE.Mesh();
  var plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0.5);
  var planeHelper = new THREE.PlaneHelper(plane,1, 0xffff00);
  //scene.add( planeHelper );

  var boxHelper;

  var material = new THREE.MeshBasicMaterial();
  let localPlane1 = new THREE.Plane();
  let localPlane2 = new THREE.Plane();
  let localPlane3 = new THREE.Plane();
  let localPlane4 = new THREE.Plane();
  let localPlane5 = new THREE.Plane();
  let localPlane6 = new THREE.Plane();
  
var loader = new THREE.PLYLoader();  
loader.load( './three/male02/integrated_rits.ply', function( geometry ){
    //const texture = loader.load('./three/male02/cal.jpg');
    localPlane1 = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 2.5);
    localPlane2 = new THREE.Plane(new THREE.Vector3(0, -1, 0), 1.5);
    localPlane3 = new THREE.Plane(new THREE.Vector3(0, 0, -1), 2);
    localPlane4 = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0.5);
    localPlane5 = new THREE.Plane(new THREE.Vector3(0, 1, 0), 1.5);
    localPlane6 = new THREE.Plane(new THREE.Vector3(0, 0, 1), 2);
    material = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.VertexColors} ); 
    //material.map= texture; 
    //var material = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.VertexColors, clippingPlanes: [localPlane1,localPlane2]} );       
    material.wireframe = false; 
    console.log(localPlane1.constant);         
    var mesh = new THREE.Mesh( geometry, material);          
    mesh.position.set(0., 0., 0.);
    mesh.position.set(0., 0., -1);          
    mesh.scale.set(1., 1., 1.);          
    mesh.castShadow = true;    
    mesh.rotation.z = Math.PI;    
    scene.add( mesh );
    boxHelper = new THREE.BoxHelper( mesh );
    scene.add( boxHelper );

});

const geometry1 = new THREE.BoxGeometry(1,1,1);
const edges = new THREE.EdgesGeometry( geometry1 );
const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x990000 } ) );
line.position.set(1,0,0);
//line.scale.set(2,2,2);
//scene.add( line );
var cube = new THREE.Mesh(                                   
     geometry1,                          
     new THREE.MeshPhongMaterial({                                      
               color: 0x990000, //球の色
               wireframe: true
      }));

      objects.push(cube);
      var world = cube.getWorldPosition(new THREE.Vector3());
      console.log(world.x);
      console.log(world.y);
      console.log(world.z);
      
      console.log(cube.geometry.parameters.width+":"+cube.geometry.parameters.height+":"+cube.geometry.parameters.depth);
      var X1 =world.x+cube.geometry.parameters.width/2;
      var Y1 =world.y+cube.geometry.parameters.height/2;
      var Z1 =world.z+cube.geometry.parameters.depth/2;
      var X2 =world.x-cube.geometry.parameters.width/2;
      var Y2 =world.y-cube.geometry.parameters.height/2;
      var Z2 =world.z-cube.geometry.parameters.depth/2;
      console.log("X1="+X1);
      console.log("Y1="+Y1);//floatで表示される
      console.log("Z1="+Z1);
      console.log("X2="+X2);
      console.log("Y2="+Y2);
      console.log("Z2="+Z2);



      //planeHelpers
  var plane1 = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 2.5);
  var planeHelper1 = new THREE.PlaneHelper(plane1,3, 0x990000);
  //scene.add( planeHelper1 );

  var plane2 = new THREE.Plane(new THREE.Vector3(0, 1, 0), -Y1);
  var planeHelper2 = new THREE.PlaneHelper(plane2,3, 0x990000);
  //scene.add( planeHelper2 );

  var plane3 = new THREE.Plane(new THREE.Vector3(0, 0, 1), -Z1);
  var planeHelper3 = new THREE.PlaneHelper(plane3,3, 0x990000);
  //scene.add( planeHelper3 );

  var plane4 = new THREE.Plane(new THREE.Vector3(1, 0, 0), -X2);
  var planeHelper4 = new THREE.PlaneHelper(plane4,3, 0x990000);
  //scene.add( planeHelper4 );

  var plane5 = new THREE.Plane(new THREE.Vector3(0, 2, 0), -Y2);
  var planeHelper5 = new THREE.PlaneHelper(plane5,3, 0x990000);
  //scene.add( planeHelper5 );

  var plane6 = new THREE.Plane(new THREE.Vector3(0, 0, 0), -Z2);
  var planeHelper6 = new THREE.PlaneHelper(plane6,3, 0x990000);
  //scene.add( planeHelper6 );

  // この平面に対してオブジェクトを平行に動かす
var planeX = new THREE.Plane();
 
 var raycaster = new THREE.Raycaster();
 var mouse = new THREE.Vector2();
 var offset = new THREE.Vector3();
 var intersection = new THREE.Vector3();
  
 // マウスオーバーしているオブジェクト
 var mouseoveredObj;
 // ドラッグしているオブジェクト
 var draggedObj;
 /* 
 renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
 renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
 renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
*/
/************************************************************************************/
/*
 function onDocumentMouseDown( event ) {
  event.preventDefault();
  console.log("MouseDown!!!");
  
  raycaster.setFromCamera( mouse, camera );
  var intersects = raycaster.intersectObjects( objects );
  
  if ( intersects.length > 0 ) {
   // マウスドラッグしている間はTrackballControlsを無効にする
   controls.enabled = false;
  
   draggedObj = intersects[ 0 ].object;
  
   // rayとplaneの交点を求めてintersectionに設定
   if ( raycaster.ray.intersectPlane( planeX, intersection ) ) {
    // ドラッグ中のオブジェクトとplaneの距離
    offset.copy( intersection ).sub( draggedObj.position );
   }
  }
 }
  
  renderer.domElement.addEventListener('touchstart', function(event) {
  event.preventDefault();
  console.log("MouseDown!!!");
  
  raycaster.setFromCamera( mouse, camera );
  var intersects = raycaster.intersectObjects( objects );
  
  if ( intersects.length > 0 ) {
   // マウスドラッグしている間はTrackballControlsを無効にする
   controls.enabled = false;
  
   draggedObj = intersects[ 0 ].object;
  
   // rayとplaneの交点を求めてintersectionに設定
   if ( raycaster.ray.intersectPlane( planeX, intersection ) ) {
    // ドラッグ中のオブジェクトとplaneの距離
    offset.copy( intersection ).sub( draggedObj.position );
   }
  }
}, false);

  /*
 function onDocumentMouseMove( event ) {
  event.preventDefault();
  
  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  
  raycaster.setFromCamera( mouse, camera );
  
  if ( draggedObj ) {
   // オブジェクトをドラッグして移動させているとき
  
   // rayとplaneの交点をintersectionに設定
   if ( raycaster.ray.intersectPlane( planeX, intersection ) ) {
    // オブジェクトをplaneに対して平行に移動させる
    draggedObj.position.copy( intersection.sub( offset ) );
    //変数更新
    X1 =draggedObj.position.x+cube.geometry.parameters.width/2;
    Y1 =draggedObj.position.y+cube.geometry.parameters.height/2;
    Z1 =draggedObj.position.z+cube.geometry.parameters.depth/2;
    X2 =draggedObj.position.x-cube.geometry.parameters.width/2;
    Y2 =draggedObj.position.y-cube.geometry.parameters.height/2;
    Z2 =draggedObj.position.z-cube.geometry.parameters.depth/2;
   }
  } else {
    
   // オブジェクトをドラッグしないでマウスを動かしている場合
   var intersects = raycaster.intersectObjects( objects );
  
   if ( intersects.length > 0 ) {
    if ( mouseoveredObj != intersects[ 0 ].object ) {
     // マウスオーバー中のオブジェクトを入れ替え
     mouseoveredObj = intersects[ 0 ].object;
  
     // plane.normalにカメラの方向ベクトルを設定
     // 平面の角度をカメラの向きに対して垂直に維持する
     camera.getWorldDirection( planeX.normal );
    }
   } else {
    mouseoveredObj = null;
   }
  }
 }
 
  
 renderer.domElement.addEventListener('touchmove', function(event) {
  event.preventDefault();
  
  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  
  raycaster.setFromCamera( mouse, camera );
  
  if ( draggedObj ) {
   // オブジェクトをドラッグして移動させているとき
  
   // rayとplaneの交点をintersectionに設定
   if ( raycaster.ray.intersectPlane( planeX, intersection ) ) {
    // オブジェクトをplaneに対して平行に移動させる
    draggedObj.position.copy( intersection.sub( offset ) );
    //変数更新
    X1 =draggedObj.position.x+cube.geometry.parameters.width/2;
    Y1 =draggedObj.position.y+cube.geometry.parameters.height/2;
    Z1 =draggedObj.position.z+cube.geometry.parameters.depth/2;
    X2 =draggedObj.position.x-cube.geometry.parameters.width/2;
    Y2 =draggedObj.position.y-cube.geometry.parameters.height/2;
    Z2 =draggedObj.position.z-cube.geometry.parameters.depth/2;
   }
  } else {
    
   // オブジェクトをドラッグしないでマウスを動かしている場合
   var intersects = raycaster.intersectObjects( objects );
  
   if ( intersects.length > 0 ) {
    if ( mouseoveredObj != intersects[ 0 ].object ) {
     // マウスオーバー中のオブジェクトを入れ替え
     mouseoveredObj = intersects[ 0 ].object;
  
     // plane.normalにカメラの方向ベクトルを設定
     // 平面の角度をカメラの向きに対して垂直に維持する
     camera.getWorldDirection( planeX.normal );
    }
   } else {
    mouseoveredObj = null;
   }
  }
}, false);
*/
  /*
 function onDocumentMouseUp( event ) {
  event.preventDefault();
  
  controls.enabled = true;

  if ( mouseoveredObj ) {
   draggedObj = null;
  }
  
 }

 

 renderer.domElement.addEventListener('touchend', function(event) {
  event.preventDefault();
  controls.enabled = true;
  if ( mouseoveredObj ) {
   draggedObj = null;
  }
}, false);
*/
/******************************************************************************/

 function inputChange(){
    // イベントが発生した時の処理
    cube.scale.set(sliderWidth.value,sliderHeight.value,sliderDepth.value);
    console.log(cube.scale.x);

}
let sliderWidth = document.getElementById('sliderWidth');
sliderWidth.addEventListener('input', inputChange);
let sliderHeight = document.getElementById('sliderHeight');
sliderHeight.addEventListener('input', inputChange);
let sliderDepth = document.getElementById('sliderDepth');
sliderDepth.addEventListener('input', inputChange);

/////////////////////////////////////////////////////////////////////////////////////**************************///////////////////////////////////////////////////////////////
let cropping_button = document.getElementById('cropbutton');
cropping_button.addEventListener('click', croppingClick);


function croppingClick(){
  X1 =world.x+cube.scale.x/2;
  Y1 =world.y+cube.scale.y/2;
  Z1 =world.z+cube.scale.z/2;
  X2 =world.x-cube.scale.x/2;
  Y2 =world.y-cube.scale.y/2;
  Z2 =world.z-cube.scale.z/2;
  localPlane1.constant = X1;
  localPlane2.constant = Y1;
  localPlane3.constant = Z1;
  localPlane4.constant = -X2;
  localPlane5.constant = -Y2;
  localPlane6.constant = -Z2;
  material.clippingPlanes = [localPlane1,localPlane2,localPlane3,localPlane4,localPlane5,localPlane6];
  boxHelper.update();
  scene.remove(cube);


  const exporter = new PLYExporter();
  const data = exporter.parse( mesh );
  downloadFile( data );
}

function updateCube(){
  world = cube.getWorldPosition(new THREE.Vector3());
}

let cropmode_button = document.getElementById('Cropmode');
cropmode_button.addEventListener('click', Cropmode);

function Cropmode(){
  
	if(cropping_button.style.visibility=="visible"){
		// hiddenで非表示
    cropping_button.style.visibility ="hidden";
    cropmode_button.value="Cropmode:ON";
    scene.remove(cube);
	}else{
		// visibleで表示
		cropping_button.style.visibility ="visible";
    cropmode_button.value="Cropmode:OFF";
    scene.add(cube);
  }
}

////////////////////////////////////////////////////////////////////******************************************///////////////////////////////////////////////////////

 // 実行
 animate();
 function animate(){
  requestAnimationFrame(animate);//★追加 アニメーション実行
  //obj.rotation.y += 0.002; //★追加 3Dオブジェクトを自動回転させる
    controls.update();
  renderer.render(scene, camera);
    
 };

 // ★追加 画面リサイズ
 onResize();
 window.addEventListener('resize', onResize);

 function onResize() {
  var width = window.innerWidth;
  var height = window.innerHeight;

  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(width, height);

  camera.aspect = width / height;
  camera.updateProjectionMatrix();
 }
</script>
</body>
</html>